# 操作系统 内存管理

## 基础知识

内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。

在多道程序环境下，系统中会有多个程序并发执行，即会有不同的程序数据同时放到内存中，需要区分各个程序的数据放在内存中的位置--给内存的存储单元编地址：1. 按字节编址，每个存储单元大小为1字节；2. 按字长编址，每个存储单元大小为1字长，具体大小视计算机而定（32位、64位）。

进程的运行时，对CPU来说看到的都是01二进制指令，每一个指令会有一个操作码，告诉CPU接下来要进行的动作，不同的指令会对应一些不同的参数，比如数据在内存中的存放位置。编译时生成的指令中一般是使用逻辑地址（相对地址）。

<img src="https://i.loli.net/2021/06/28/zraDSQ3xh1PekCF.png" alt="写程序到程序运行" style="zoom: 67%;" />

装入的三种方式（完成逻辑地址到物理地址的转换）：

1. 绝对装入

   在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据放入内存。即编译、链接后得到的装入模块的指令直接使用了绝对地址。

   一般适合单道程序环境，内存中同一时刻只有一个程序。

2. 静态重定位

   可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址相对于其实地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置，装入时对地址进程“重定位”，将逻辑地址转换为物理地址（地址变换是在装入时一次完成的）

   静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间也不能再移动，也不能再申请内存空间。

3. 动态重定位

   动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。银日装入内存后所有的地址依然为逻辑地址。这种方式需要一个重定位寄存器支持，用于存放装入模块存放的起始位置。

   该方法允许程序再内存中发生移动。并且可以将程序分哦到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大的多的地址空间。

链接的三种方式：

1. 静态链接
2. 装入时动态链接
3. 运行时动态链接

## 内存管理的概念

操作系统要怎么记录哪些内存区域已经被分配出去了，又有哪些是空闲的；很多位置都可以放新的进程，应该放在哪里；当进程运行结束后，如何将进程占用的内存空间回收？即**操作系统负责内存空间的分配与回收**。

GTA大小超过60G，电脑内存才8G，为什么能顺利运行？即**操作系统需要提供某种技术从逻辑上对内存空间进行扩充**（虚拟技术）。

地址重定位（逻辑地址到物理地址的转换）应该由操作系统负责，保证程序员在写程序时不需要关注物理内存的实际情况。即**操作系统需要提供地址转换功能即是三种装入方式**。

**操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰**。<br>两种方法：1. 在CPU设置一对上、下限寄存器，存放某个进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界；2. 采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查、重定位寄存器中存放的是进程的起始物理地址。界地址寄存器存放的是进程的最大逻辑地址。

![](https://i.loli.net/2021/06/28/PeUDTpz8xfKM9FX.png)



## 内存空间的扩充

### 覆盖与交换技术

#### 覆盖技术

解决程序大小超过物理内存总和的问题。

思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。

内存也要分为一个“固定区”和若干个"覆盖区"。需要常驻内存的段放在“固定区”，调入后就不再调出（除非运行结束）。不常用的段放在"覆盖区"，需要时调入到内存，用不到时调出内存。

<img src="https://i.loli.net/2021/06/28/L9WlUupf42twQJT.png" style="zoom:67%;" />

必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点是对用户不透明，增加了用户编程负担。只用于早期的操作系统，已退出历史舞台。

#### 交换技术

思想：内存空间紧张时，系统将内存中的某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。

1. 应该在外存（磁盘）的什么位置保存被换出的进程？

   具有交换功能的操作系统，通常把磁盘文件分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的高利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。（对换区的I/O速度快）

2. 什么时候应该交换？

   交换通常在许多进程运行在内存吃紧时进行，而系统负荷降低就暂停。例如在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。

3. 应该换出哪些进程？

   可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间......

   >PCB 会常驻内存，不会被换出外存

>覆盖是在同一个程序或进程中执行的，而交换是在不同进程（作业）间进行的。

### 虚拟存储技术

[见后面](##虚拟内存)

## 内存空间的分配与回收

### 连续分配管理方式

连续分配指用户进程分配的必须是一个连续的内存空间。

#### 单一连续分配

![](https://i.loli.net/2021/06/28/RoIXer6Zvmx4clS.png)

#### 固定分区分配

![](https://i.loli.net/2021/06/28/KB4IT6mFUvkjdHM.png)

操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。

优点：实现简单、无外部锁片。

缺点：1. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术解决，但这会降低性能；2. 会产生内部碎片，内存利用率低。

#### 动态分区分配

又称可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

1. 系统需要用什么养的数据结构记录内存的使用情况？

   两种常见的数据结构：1. 空间分区表；2. 空闲分区链

   ![](https://i.loli.net/2021/06/28/FzYvMtExaXkKIyQ.png)

2. 当有很多个空闲分区都能满足要求时，应该选择哪个分区进行分配？

   把一个作业装入内存时，需要按照一定的**动态分区分配算法**，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。

3. 如何进行分区的分配与回收操作？

   起始就是对空间分区表或这空闲分区链进行维护。<br>1. 回收区之后有相邻的空闲分区<br>2. 回收区之前有相邻的空闲分区<br>3. 回收区前、后都有相邻的空闲分区<br>4. 回收区前、后都没有相邻的空闲分区

动态分区分配没有内部碎片，但有外部碎片。<br>1. 内部碎片：分配给某进程的内存区域，如果有些部分没有用上<br>2. 外部碎片：是指内存中的某些空闲分区太小而难以利用。

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过**紧凑（拼凑）技术**来解决外部碎片

#### 动态分区分配算法

1. 首次适应算法：每次都从低地址开始查找，找到第一个满足大小的空闲分区。<br>实现：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区。
2. 最佳适应算法：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须时连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能地留下大片的空闲区，即优先使用更小的空闲区。<br>实现：空闲分区以容量递增的次序排列，每次分配内存时顺序查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区。<br>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。这种方法会产生很多的外部碎片。
3. 最坏适应算法：最大适应算法。为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时使用最大的连续空闲区，这样分配后的剩余空闲区就不会太小，更方便使用。<br>实现：空闲分区以容量递减的次序排列，每次分配内存时顺序查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区。<br>缺点：每次都选最大的分区进行分配，可能导致后面的“大进程”没有可用内存分区。
4. 邻近适应算法：首次适应算法每次都是从链头开始查找，这可能导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。解决办法就是每次都从上次查找结束的位置开始检索。<br>实现：空闲分区以地址递增的次序排列（可排成一个循环链表），每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。<br>集最佳适应算法的优点与最大适应算法的缺点。

![](https://i.loli.net/2021/06/28/zYBCAecogV57bSl.png)



### 非连续分配管理方式

#### 基本分页存储管理

将内存空间分为一个个大小相等的分区，每一个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即”页框号“（内存块号、页帧号、物理块号）。页框号从0开始。

将用户进程的地址空间也分为与页框小大相等的一个个区域，称为”页“或者”页面“。每个页面也有一个编号，即”页号“，页号也是从0开始。

进程的最后一个页面可能没有一个页框那么大，因此页匡不能太大，否则可能产生过大的内部碎片。

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入到一个页框中。即进程的页面与内存的页框有一一对应的关系。

各个页面不必连续存放，与不必按先后顺序存放，可以放到不相邻的各个页框中。

![](https://i.loli.net/2021/06/28/6XLuyGrVtCw17cn.png)

![](https://i.loli.net/2021/06/28/Xt3ufnNcqRPK2JH.png)

![](https://i.loli.net/2021/06/28/5BR4G6LuFi8Ymb1.png)

![](https://i.loli.net/2021/06/28/Oi75suajLvESlBH.png)

![](https://i.loli.net/2021/06/28/jZ9LVGkundAecEP.png)

![](https://i.loli.net/2021/06/28/PZoVLIaYhXncSCD.png)

#### 基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始位置F和页表长度M。进程未执行时，页表的始址和页表长度放在程序控制块PCB中，当进程被调度时，操作系统内核会把他们放入到页表寄存器中。

#### 具有快表的地址变换机构

**局部性原理**

时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很有可能再次被访问（因为程序中存在大量的循环）。

空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也有可能被访问（因为很多数据在内存中都是连续存放的）。

在基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。

**快表**

又称联想寄存器（TLB），是一种访问速度比内存快很多的高级缓冲存储器，用来存放当前访问的若干表项，以加速地址变换的过程。与之对应，内存中的页表常常被称为慢表。

![](https://i.loli.net/2021/06/28/xVL7nF1bCrZEea3.png)

若快表已满，则必须按照一定的算法对旧的页表项进行替换。

由于查询快表的速度要比查询页表的速度快很多，因此只要快表命中。就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。

有的系统支持快表和慢表同时查找。

#### 两级页表

![](https://i.loli.net/2021/06/29/gspEH3MfSejU6Ku.png)

根据局部性原理，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表在内存中常驻。

>单级页表存在的问题：
>
>* 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框
>* 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

（偷懒偷懒）

![](https://i.loli.net/2021/06/29/V9j4nJ1fLveCEaP.png)

![](https://i.loli.net/2021/06/29/Ldi2cvZWP8Nk9RT.png)

![](https://i.loli.net/2021/06/29/ACgYPF5sUZNIKE8.png)

![](https://i.loli.net/2021/06/29/bt6xWLV9wzJlFra.png)

![](https://i.loli.net/2021/06/29/IGHeyfxsvJTnmF9.png)

一个原则：采用多级页表机制，各级页面的大小不能超过一个页面。 两级页表不够，可以分更多级。

#### 基本分段存储管理

按照进程自身的逻辑划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。比如按照main函数，子函数，保存的全局变量进行分段。

> 编译程序会把段名转换为段号。CPU根据段号区分各个段。

内存分配原则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）所组成：<br>1. 段号的位数决定了每个进程最多可以分几个段<br>2. 段内地址位数决定了每个段的最大长度为多少

类似分页存储管理，需要段表完成从逻辑地址到物理地址的转换。<br>1. 每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称基址）和段的长度<br>2. 各个段表项的长度是相同的。

![](https://i.loli.net/2021/06/29/c6klDaP9zLe3qCZ.png)

[![RdsdmR.png](https://z3.ax1x.com/2021/06/29/RdsdmR.png)](https://imgtu.com/i/RdsdmR)

[![Rdsc1e.png](https://z3.ax1x.com/2021/06/29/Rdsc1e.png)](https://imgtu.com/i/Rdsc1e)



#### 段页式管理方式

分页管理：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片，缺点是不方便按照逻辑模块实现信息的共享与保护。

分段管理：很方便按照逻辑模块实现信息的共享与保护。但如果段长过大，为其分配很大的连续空间会很不方便，而且会产生外部碎片（不紧凑的话，紧凑需要付出较大的时间代价）。

段页式管理就是将进程按逻辑分段，再将各段分页，再将内存空间分为大小相同的内存块（页帧/页框/物理块），进程执行前将各页面分别装入内存块中。

![](https://i.loli.net/2021/06/29/rUoaMRNLlneFQsc.png)

## 虚拟内存

传统存储管理方式的特征、缺点：

![](https://i.loli.net/2021/06/29/ubqEcHoUjYn4ahe.png)

虚拟存储管理技术是基于局部性原理提出的。也依赖于高速缓存技术的发展

> 高速缓存技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中。
>
> 快表就是将近期常访问的页表项副本放到更高速的联想寄存器中。

![](https://i.loli.net/2021/06/29/QSPaXJR9IqcGkli.png)

虚拟内存的实现需要建立在离散分配的内存管理方式基础上，因为一个作业要分多次调入内存，采用连续分配方式不便实现。

![](https://i.loli.net/2021/06/29/VLv7t6lK9XuNDdz.png)

### 请求分页管理方式

与基本分页存储管理的主要区别就是在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，还需要操作系统负责将内存中暂时用不到的信息换出到外存。即操作系统要负责请求调页功能和页面置换功能。

#### 页表机制

![](https://i.loli.net/2021/06/29/WE5uHOeKfv4LaSj.png)

#### 缺页中断机构

![](https://i.loli.net/2021/06/29/OFWKsMuxtBGkYAU.png)

在请求分页管理系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断，此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列：

1. 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中的对象的页表项；
2. 如果内存中没有空闲块，则由**页面置换算法**选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。

#### 地址变换机构

对比基本分页存储管理，新增：

* 请求调页（查找页表项时进行判断，状态位）
* 页面置换（需要调入页面，但没有空闲内存块时进行）
* 需要修改请求页表中新增的表项。

![](https://i.loli.net/2021/06/29/loDHmcCJOBtdwjG.png)

在具有快表的请求分页系统中，访问一个逻辑地址时，若发生缺页，地址变换的步骤是：查快表（未命中）--> 查慢表（发现未调入内存）--> 调页（调入的页面对应的表项会直接加入快表） -->  查快表（命中） --> 访问目标内存单元。

#### 页面置换算法

页面的换入、换出需要磁盘的I/O，会有较大的开销，因此好的置换页面算法应该追求更少的缺页率。

**最佳置换算法（OPT）**

每次选择淘汰的页面将是以后永不使用或者在最长时间内不再被访问的页面，以保证最低的缺页率。

怎么预计未来？应该是理论上页面置换算法的最佳情况，实际无法实现。

**先进先出置换算法（FIFO）**

每次选择淘汰的页面是最早进入内存的页面。（队列）。队列的最大长度取决于系统为进程分配了多少个内存块。

Belady异常，当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

只有FIFO会产生Belady异常。最先置换的页面可能会是最常访问的。

**最近最久未使用置换算法（LRU）**

每次淘汰的页面是最近最久未使用的页面。

实现方法：赋予每个页面对应的表项中，用访问字段记录该页面上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有的页面中t值最大的，即最近最久未使用的页面。

> 最接近最佳置换算法，但是算法开销较大的

**时钟置换算法**

应该是有两个，一个查找指针、一个扫描指针。查找指针去查找是否在页面是否在页表中（表，这里是链表），找到了（命中）只需把命中页面的访问位置为1，而扫描指针不动。当发生缺页是（没有命中），扫描指针开始移动，寻找访问位为0的页面，且扫过的位置访问为置为0，直到找到第一个访问位为0的页面进行替换，且指针指向下一个位置。

![](https://i.loli.net/2021/06/29/domMcz9nE5y2SKO.png)

**改进型时钟置换算法**

![](https://i.loli.net/2021/06/29/T5u9tvBMx8FyrHn.png)

#### 页面分配策略

![](https://i.loli.net/2021/06/29/qdDaKnZohebm1Nz.png)

![](https://i.loli.net/2021/06/29/CIZ58XnGLHFPOiN.png)

![](https://i.loli.net/2021/06/29/M9BhrY37d8aFEwb.png)

![](https://i.loli.net/2021/06/29/lNAsfDdxX4qU1je.png)

![](https://i.loli.net/2021/06/29/tUgWjZyaipDBNHc.png)

![](https://i.loli.net/2021/06/29/OJTpf8M1V2LHkv6.png)

![](https://i.loli.net/2021/06/29/pRZFeiaosJPXx3k.png)

![](https://i.loli.net/2021/06/29/9efOdsDz8yCjgR1.png)

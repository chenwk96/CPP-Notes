# 操作系统 进程管理

## 进程

### 进程的概念

**进程的定义**

程序:就是一个指令序列。

程序段、数据段、PCB三部分组成了**进程实体(进程映像)**。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

> PCB是进程存在的唯一标志 !

从不同的角度，进程可以有不同的定义，比较传统典型的定义有:
1.进程是程序的一次**执行过程**。
2.进程是一个程序及其数据在处理机上顺序执行时所**发生的活动**。
3.进程是具有独立功能的程序在数据集合上**运行的过程**，它是系统进行资源分配和调度的一个独立单位。

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

注:严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。

**进程的组成**

![](https://i.loli.net/2021/07/01/F1mWeqZdj9EI2kV.png)

> 进程的管理者(操作系统)所需的数据都在PCB中
>
> 程序本身的运行所需的数据存放在程序段和数据段中

**PCB**

![](https://i.loli.net/2021/07/01/zLCPif4odnFmW2T.png)

**进程的组织**

在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。

![](https://i.loli.net/2021/07/01/4zBXyjo3wWLUT6f.png)

**进程的特征**

![](https://i.loli.net/2021/07/01/tBqDfGnC1w87JYM.png)

### 进程状态及转换

**三种基本状态**

进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。

![](https://i.loli.net/2021/07/01/Bqaxfvw1jlF5ZXc.png)

> 注意:单核处理机环境下，每时刻最多只有一个进程处于运行态。(双核环境下可以同时有两个进程处于运行态)
>
> 就绪态：进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即:万事俱备，只欠CPU
>
> 阻塞态：如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务

**另外两种状态**

操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB (如:为进程分配PID)。

进程运行结束(或者由于bug导致进程无法继续执行下去，比如数组越界错误)，需要撤销进程。

> 操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作

![](https://i.loli.net/2021/07/01/AktqiobBXy7J4ZW.png)

**进程状态的转换**

![](https://i.loli.net/2021/07/01/7FuAEqlDvm2LsCZ.png)

### 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

**使用原语实现进程控制**

如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作

例：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…，此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：<br>①将PCB2的 state 设为1<br>②将PCB2从阻塞队列放到就绪队列<br>但完成了第一步后收到中断信号，那么PCB2的state=1，但是它却被放在阻塞队列里

**如何实现原语的“原子性”？**

可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性

正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。**CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”**

**进程控制相关的原语**

1. 创建原语

   ![](https://i.loli.net/2021/07/01/tPuEcWRVICyXhj2.png)

2. 撤销原语

   ![](https://i.loli.net/2021/07/01/obv54pJzAZkuBTV.png)

3. 阻塞、唤醒

   ![](https://i.loli.net/2021/07/01/S5KalAG7nYw3gNF.png)

4. 进程切换

   ![](https://i.loli.net/2021/07/01/gmOGrZ7QFfnaNhS.png)

> 更新PCB中的信息
> a. 所有的进程控制原语一定都会修改进程状态标志
> b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
> c. 某进程开始运行前必然要恢复期运行环境
>
> 将PCB插入合适的队列
>
> 分配 / 回收资源

**如何实现进程的控制**

![](https://i.loli.net/2021/07/01/hp7kO6XcG3J9ryu.png)

### 进程通信

进程通信就是指进程之间的信息交换。

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

但是进程之间的信息交换又是必须实现的。

常见的有管道通信、共享存储、消息传递。



## 线程

当切换进程时，需要保存 / 恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销很大。

同一进程内的各个线程间并发，不需要切换进程运行环境和内存地址空间，省时省力。从属于同一进程的各个线程共享进程的资源。

引入线程机制后，并发带来的系统开销降低，系统并发性提升：

* 引入线程前，进程既是资源分配的基本单位，也是调度的基本单位。

* 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。线程也有运行态、就绪态、阻塞态

在多CPU环境下，各个线程也可以分派到不同的CPU上并行地执行。

线程几乎不拥有资源，只拥有极少量的资源（线程控制块TCB、寄存器信息、堆栈等）

### **线程的实现方式多线程模型**

**用户级**

早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的

![](https://i.loli.net/2021/07/01/caJmZuwUhFiQIvl.png)

1. 用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）
2. 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
3. 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”
4. 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
5. 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

**内核级**

内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”） 由操作系统支持的线程

![](https://i.loli.net/2021/07/01/jNfVIcTzJKMUYsP.png)

1. 内核级线程的管理工作由操作系统内核完成。
2. 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
3. 操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”
4. 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
5. 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

**多线程模型**

在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型

**一对一模型**：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

* 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
* 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

**多对一模型**：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程

* 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
* 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

> 操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。

**多对多模型**： n 用户及线程映射到m 个内核级线程（n >= m）。每个用户进程对应 m 个内核级线程。

克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

> 可以这么理解：
>
> 1. 用户级线程是“代码逻辑”的载体 
> 2. 内核级线程是“运行机会”的载体 
> 3.  一段“代码逻辑”只有获得了“运行机会”才能被CPU执行

内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞



## 处理机的调度

### 调度的基本概念

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。

在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。

### 调度的三个层次

**高级调度**

![](https://i.loli.net/2021/07/01/CYcoOb1IzqFGVJp.png)

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。

高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。

高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

**中级调度**

![](https://i.loli.net/2021/07/01/J6eQXvSfcOj43Fm.png)

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了提高内存利用率和系统吞吐量。

暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。

中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。

一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

**低级调度**

![](https://raw.githubusercontent.com/chenwk96/picgoImage/main/20210701170741.png)

低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。

### 进程（低级）调度的时机切换与过程调度方式

**进程调度的时机**

进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机

![](https://raw.githubusercontent.com/chenwk96/picgoImage/main/20210701171036.png)

内核程序临界区与临界区不一样，一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。而临界区指访问临界资源的那段代码。进程在普通临界区中是可以进行调度、切换的。

**进程调度的方式**

非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统

**进程的切换与过程**

狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）

进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

**调度算法的评价指标**

* CPU利用率：指CPU “忙碌”的时间占总时间的比例。
* 系统吞吐量：单位时间内完成作业的数量
* 周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。
  * 作业在外存后备队列上等待作业调度（高级调度）的时间、
  * 进程在就绪队列上等待进程调度（低级调度）的时间、
  * 进程在CPU上执行的时间、
  * 进程等待I/O操作完成的时间。
  * 对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值
* 等待时间：指进程 / 作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。
  * 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
  * 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间
* 响应时间：指从用户提交请求到首次产生响应所用的时间。


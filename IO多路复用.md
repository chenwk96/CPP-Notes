# I/O多路复用

在通信的服务器端有两类文件描述符，一个是监听新的客户端连接的文件描述符，另一个是用于通信的文件描述符，他们在内核中都对应两块缓冲区（读、写）

<img src="https://i.loli.net/2021/06/12/VlyS7DUbOC8Gt1g.png" alt="服务器两种文件描述符" style="zoom:80%;" />

当线程只有一个的情况下，`accept()`、`read()/receive()`、`write()/send()`函数其中有一个阻塞都会导致整个进程阻塞，即单线程下是不能同时处理这三个函数的阻塞。当使用I/O多路复用时，监听和通信的Read Buffer和Write Buffer的检测就会交给内核来维护，内核能够同时检测若干个文件描述符（包括监听和通信）的读、写缓冲区 ，如果监听的读缓冲区有数据或者写缓冲区未满，如果条件满足，相当于有一个对应的事件，内核就会把这些能够操作（读操作==或者==写操作，应该是有一个能够操作即可）的文件描述符告诉使用者，这样的话再调用`accept()`、`read()/receive()`、`write()/send()`函数时就不会发生阻塞。如果内核检测的结果有多个文件操作符满足条件，这些事件的执行时串行的，按照顺序执行而不是同时执行。同时处理触发的相关事件就要采用多线程。

>I/O多路复用相当于把程序员需要进行的读缓冲区、写缓冲区的检测交给了内核处理。内核检测一轮后就会把可以进行读、写操作的文件描述符告诉我们。接下来就能进行建立新连接，或者读写数据的操作了。



## Select

### `select()`函数

首先`select()`函数跨平台，而`poll(),epoll()`只支持Linux。

通过调用这个函数可以委托内核帮助我们检测若干个（N+1，N表示用于通信的，1是监听的）文件描述符的状态，其实就是检测这些文件描述符对应的读写缓冲区的状态：

* 读缓冲区：检测里边有没有数据，如果有数据该缓冲区对应的文件描述符就绪
* 写缓冲区：检测写缓冲区是否可以写 (有没有容量)，如果有容量可以写，缓冲区对应的文件描述符就绪
* 读写异常：检测读写缓冲区是否有异常，如果有该缓冲区对应的文件描述符就绪

```c++
#include <sys/select.h>
struct timeval {
    time_t tv_sec;			// seconds
    suseconds_t tv_usec;	// microseconds
};

int select(int nfds, fd_set* readfds, fd_set* writfds,
          fd_set* exceptfds, struct timeval* timeout);
```

函数参数：

* nfds：委托内核检测的这三个集合中最大的文件描述符 + 1
  * 内核需要线性遍历这些集合中的文件描述符，这个值是循环结束的条件
  * 在 Window 中这个参数是无效的，指定为 - 1 即可
  * 文件描述符默认情况下最多有1024个
* readfds：文件描述符的集合，内核只检测这个集合中文件描述符对应的读缓冲区
  * 传入传出参数，读集合一般情况下都是需要检测的，这样才知道通过哪个文件描述符接收数据
* writefds：文件描述符的集合，内核只检测这个集合中文件描述符对应的写缓冲区
  * 传入传出参数，如果不需要使用这个参数可以指定为 NULL
* exceptfds：文件描述符的集合，内核检测集合中文件描述符是否有异常状态
  * 传入传出参数，如果不需要使用这个参数可以指定为 NULL
* timeout：超时时长，用来强制解除 select () 函数的阻塞的
  * NULL：函数检测不到就绪的文件描述符会一直阻塞。
  * 等待固定时长（秒）：函数检测不到就绪的文件描述符，在指定时长之后强制解除阻塞，函数返回 0
  * 不等待：函数不会阻塞，直接将该参数对应的结构体初始化为 0 即可。

函数返回值为个数：

* 大于 0：成功，返回集合中已就绪的文件描述符的总个数
* 等于 - 1：函数调用失败
* 等于 0：超时，没有检测到就绪的文件描述符

> 当调用`select()`函数成功时，`readfds, writefds,excepfds`指针指向的内容会被内核进行修改，返回能够进行操作的文件描述符。
>
> 如果内核在检测过程中三个集合中均没有满足条件的文件描述符，就会发生阻塞，可以通过设置timeout参数强制解除
>
> 一般在服务器端只需要检测读缓冲区即可，或者根据实际情况检测异常，写缓冲区一般都是空的，能够写数据

`fd_set`类型占用内存大小是1024个bit，与系统默认的文件描述符的个数相同，其内容相当于一个标志位，每个标志位对应一个文件描述符。

* 如果集合中的标志位为 0 代表不检测这个文件描述符状态
* 如果集合中的标志位为 1 代表检测这个文件描述符状态

<img src="https://i.loli.net/2021/06/12/ODA8hPva9iQLW6J.png" style="zoom: 25%;" />

内核在遍历这个读集合的过程中，如果被检测的文件描述符对应的读缓冲区中没有数据，内核将修改这个文件描述符在读集合 `fd_set` 中对应的标志位，改为 0，如果有数据那么这个标志位的值不变，还是 1。

<img src="https://i.loli.net/2021/06/12/GJajAkUqm3rlSWB.png" style="zoom: 25%;" />

当 `select() `函数解除阻塞之后，被内核修改过的读集合通过参数传出，此时集合中只要标志位的值为 1，那么它对应的文件描述符肯定是就绪的，我们就可以基于这个文件描述符和客户端建立新连接或者通信了。

初始化 `fd_set `类型的参数还需要使用相关的一些列操作函数，具体如下：

```c++
// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0  
void FD_CLR(int fd, fd_set *set);

// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1
int  FD_ISSET(int fd, fd_set *set);

// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1
void FD_SET(int fd, fd_set *set);

// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符
void FD_ZERO(fd_set *set);
```

>`fd_set`内存在用户区，通过`select()`会把这部分内容传递到内核里面（做一次数据拷贝），内核会基于拷贝后的集合进行线性检测，检测完之后，对满足条件的文件描述符写回到原先用户区的`fd_set`，对其进行更新。拿到结果后，可以遍历该集合进行`FD_ISSET`判断，得到满足条件的文件描述符，然后再对其是监听还是通信文件描述符进行判断，如果是监听，就与新客户建立新连接，如果是通信，就进行读写数据



### 基于select进行并发

如果在服务器基于 select 实现并发，其处理流程如下：

1. 创建监听的套接字 lfd = socket ();

2. 将监听的套接字和本地的 IP 和端口绑定 bind ()

3. 给监听的套接字设置监听 listen ()

4. 创建一个文件描述符集合 fd_set，用于存储需要检测读事件的所有的文件描述符（监听的文件描述符也要放入读事件的集合中，因为监听就是监听其读缓冲区是否有数据，是否有新链接）

   * 通过 FD_ZERO () 初始化

   * 通过 FD_SET () 将监听的文件描述符放入检测的读集合中

5. 循环调用 select ()，周期性的对所有的文件描述符进行检测

6. select () 解除阻塞返回，得到内核传出的满足条件的就绪的文件描述符集合

   * 通过 FD_ISSET () 判断集合中的标志位是否为 1
     * 如果这个文件描述符是监听的文件描述符，调用 accept () 和客户端建立连接
       * 将得到的新的通信的文件描述符，通过 FD_SET () 放入到检测集合中
   * 如果这个文件描述符是通信的文件描述符，调用通信函数和客户端通信
     * 如果客户端和服务器断开了连接，使用 FD_CLR () 将这个文件描述符从检测集合中删除
     * 如果没有断开连接，正常通信即可

7. 重复第 6 步

<img src="https://i.loli.net/2021/06/12/BzerAKwc2QW7gtZ.png" style="zoom: 25%;" />

>timeout时也可以根据需求，和图中不一样，继续进行检测。

客户端不需要使用 IO 多路转接进行处理，因为客户端和服务器的对应关系是 1：N，也就是说客户端是比较专一的，只能和一个连接成功的服务器通信。

虽然使用 select 这种 IO 多路转接技术可以降低系统开销，提高程序效率，但是它也有局限性：

* 待检测集合（第 2、3、4 个参数）需要频繁的在用户区和内核区之间进行数据的拷贝，效率低

* 内核对于 select 传递进来的待检测集合的检测方式是线性的
  * 如果集合内待检测的文件描述符很多，检测效率会比较低
  * 如果集合内待检测的文件描述符相对较少，检测效率会比较高
* 使用select能够检测的最大文件描述符个数有上限，默认是1024，这是在内核中被写死了的。

为了提高效率，可以采用多线程的方法，主线程进行`select()`操作，检测满足条件的文件描述符，通过不同的线程去处理监听或者通信数据的接收。



## poll

### `poll()`函数

poll 的机制与 select 类似，与 select 在本质上没有多大差别，使用方法也类似，下面的是对于二者的对比：

* 内核对应文件描述符的检测也是以线性的方式进行轮询，根据描述符的状态进行处理
* poll 和 select 检测的文件描述符集合会在检测过程中频繁的进行用户区和内核区的拷贝，它的开销随着文件描述符数量的增加而线性增大，从而效率也会越来越低。
* select检测的文件描述符个数上限是1024，poll没有最大文件描述符数量的限制
* select可以跨平台使用，poll只能在Linux平台使用

>一般不会使用poll，跨平台考虑select，linux用epoll

poll 函数的函数原型如下：

```c++
#include <poll.h>
// 每个委托poll检测的fd都对应这样一个结构体
struct pollfd {
    int   fd;         /* 委托内核检测的文件描述符 */
    short events;     /* 委托内核检测文件描述符的什么事件 */
    short revents;    /* 文件描述符实际发生的事件 -> 传出 */
};

struct pollfd myfd[n];
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

函数参数：

* fds: 这是一个 struct pollfd 类型的数组，里边存储了待检测的文件描述符的信息，这个数组中有三个成员：

  * fd：委托内核检测的文件描述符
  * events：委托内核检测的 fd 事件（输入、输出、错误），每一个事件有多个取值
  * revents：这是一个传出参数，数据由内核写入，存储内核检测之后的结果，不用初始化

  ![](https://i.loli.net/2021/06/12/RVIS6kbFaEZ4yNt.png)

  > 同时读写可以用`POLLIN | POLLOUT`

* nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1（也可以指定参数 1 数组的元素总个数）

* timeout: 指定 poll 函数的阻塞时长
  * -1：一直阻塞，直到检测的集合中有就绪的文件描述符（有事件产生）解除阻塞
  * 0：不阻塞，不管检测集合中有没有已就绪的文件描述符，函数马上返回
  * 大于 0：阻塞指定的毫秒（ms）数之后，解除阻塞

函数返回值：

* 失败： 返回 - 1
* 成功：返回一个大于 0 的整数，表示检测的集合中已就绪的文件描述符的总个数

使用 poll 和 select 进行 IO 多路转接的处理思路是完全相同的，但是使用 poll 编写的代码看起来会更直观一些，select 使用的位图的方式来标记要委托内核检测的文件描述符（每个比特位对应一个唯一的文件描述符），并且对这个 fd_set 类型的位图变量进行读写还需要借助一系列的宏函数，操作比较麻烦。而 poll 直接将要检测的文件描述符的相关信息封装到了一个结构体 struct pollfd 中，我们可以直接读写这个结构体变量。

另外 poll 的第二个参数有两种赋值方式，但是都和第一个参数的数组有关系：

* 使用参数 1 数组的元素个数
* 使用参数 1 数组中存储的最后一个有效元素对应的下标值 + 1

内核会根据第二个参数传递的值对参数 1 数组中的文件描述符进行线性遍历，这一点和 select 也是类似的。



## epoll

epoll全称evenpoll，是linux内核实现I/O多路复用的一个实现，epoll 是 select 和 poll 的升级版，相较于这两个前辈，epoll 改进了工作方式，因此它更加高效。

* 对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。
* select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是==回调机制==，效率高，处理效率也不会随着检测集合的变大而下降
* select和poll工作过程中存在内核/用户空间数据的频繁拷贝问题，==在epoll中内核和用户区使用的是**共享内存**（基于mmap内存映射区实现）==，省去了不必要的内存拷贝。
* 使用者需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测
* 使用 epoll 没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制

当多路复用的文件数量庞大、IO 流量频繁的时候，一般不太适合使用` select () `和 `poll ()`，这种情况下` select () `和` poll () `表现较差，推荐使用 `epoll ()`。
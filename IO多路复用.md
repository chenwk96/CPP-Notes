# I/O多路复用

在通信的服务器端有两类文件描述符，一个是监听新的客户端连接的文件描述符，另一个是用于通信的文件描述符，他们在内核中都对应两块缓冲区（读、写）

<img src="https://i.loli.net/2021/06/12/VlyS7DUbOC8Gt1g.png" alt="服务器两种文件描述符" style="zoom:80%;" />

当线程只有一个的情况下，`accept()`、`read()/receive()`、`write()/send()`函数其中有一个阻塞都会导致整个进程阻塞，即单线程下是不能同时处理这三个函数的阻塞。当使用I/O多路复用时，监听和通信的Read Buffer和Write Buffer的检测就会交给内核来维护，内核能够同时检测若干个文件描述符（包括监听和通信）的读、写缓冲区 ，如果监听的读缓冲区有数据或者写缓冲区未满，如果条件满足，相当于有一个对应的事件，内核就会把这些能够操作（读操作==或者==写操作，应该是有一个能够操作即可）的文件描述符告诉使用者，这样的话再调用`accept()`、`read()/receive()`、`write()/send()`函数时就不会发生阻塞。如果内核检测的结果有多个文件操作符满足条件，这些事件的执行时串行的，按照顺序执行而不是同时执行。同时处理触发的相关事件就要采用多线程。

>I/O多路复用相当于把程序员需要进行的读缓冲区、写缓冲区的检测交给了内核处理。内核检测一轮后就会把可以进行读、写操作的文件描述符告诉我们。接下来就能进行建立新连接，或者读写数据的操作了。



## Select

### `select()`函数

首先`select()`函数跨平台，而`poll(),epoll()`只支持Linux。

通过调用这个函数可以委托内核帮助我们检测若干个（N+1，N表示用于通信的，1是监听的）文件描述符的状态，其实就是检测这些文件描述符对应的读写缓冲区的状态：

* 读缓冲区：检测里边有没有数据，如果有数据该缓冲区对应的文件描述符就绪
* 写缓冲区：检测写缓冲区是否可以写 (有没有容量)，如果有容量可以写，缓冲区对应的文件描述符就绪
* 读写异常：检测读写缓冲区是否有异常，如果有该缓冲区对应的文件描述符就绪

```c++
#include <sys/select.h>
struct timeval {
    time_t tv_sec;			// seconds
    suseconds_t tv_usec;	// microseconds
};

int select(int nfds, fd_set* readfds, fd_set* writfds,
          fd_set* exceptfds, struct timeval* timeout);
```

函数参数：

* nfds：委托内核检测的这三个集合中最大的文件描述符 + 1
  * 内核需要线性遍历这些集合中的文件描述符，这个值是循环结束的条件
  * 在 Window 中这个参数是无效的，指定为 - 1 即可
  * 文件描述符默认情况下最多有1024个
* readfds：文件描述符的集合，内核只检测这个集合中文件描述符对应的读缓冲区
  * 传入传出参数，读集合一般情况下都是需要检测的，这样才知道通过哪个文件描述符接收数据
* writefds：文件描述符的集合，内核只检测这个集合中文件描述符对应的写缓冲区
  * 传入传出参数，如果不需要使用这个参数可以指定为 NULL
* exceptfds：文件描述符的集合，内核检测集合中文件描述符是否有异常状态
  * 传入传出参数，如果不需要使用这个参数可以指定为 NULL
* timeout：超时时长，用来强制解除 select () 函数的阻塞的
  * NULL：函数检测不到就绪的文件描述符会一直阻塞。
  * 等待固定时长（秒）：函数检测不到就绪的文件描述符，在指定时长之后强制解除阻塞，函数返回 0
  * 不等待：函数不会阻塞，直接将该参数对应的结构体初始化为 0 即可。

函数返回值为个数：

* 大于 0：成功，返回集合中已就绪的文件描述符的总个数
* 等于 - 1：函数调用失败
* 等于 0：超时，没有检测到就绪的文件描述符

> 当调用`select()`函数成功时，`readfds, writefds,excepfds`指针指向的内容会被内核进行修改，返回能够进行操作的文件描述符。
>
> 如果内核在检测过程中三个集合中均没有满足条件的文件描述符，就会发生阻塞，可以通过设置timeout参数强制解除
>
> 一般在服务器端只需要检测读缓冲区即可，或者根据实际情况检测异常，写缓冲区一般都是空的，能够写数据

`fd_set`类型占用内存大小是1024个bit，与系统默认的文件描述符的个数相同，其内容相当于一个标志位，每个标志位对应一个文件描述符。

* 如果集合中的标志位为 0 代表不检测这个文件描述符状态
* 如果集合中的标志位为 1 代表检测这个文件描述符状态

<img src="https://i.loli.net/2021/06/12/ODA8hPva9iQLW6J.png" style="zoom: 25%;" />

内核在遍历这个读集合的过程中，如果被检测的文件描述符对应的读缓冲区中没有数据，内核将修改这个文件描述符在读集合 `fd_set` 中对应的标志位，改为 0，如果有数据那么这个标志位的值不变，还是 1。

<img src="https://i.loli.net/2021/06/12/GJajAkUqm3rlSWB.png" style="zoom: 25%;" />

当 `select() `函数解除阻塞之后，被内核修改过的读集合通过参数传出，此时集合中只要标志位的值为 1，那么它对应的文件描述符肯定是就绪的，我们就可以基于这个文件描述符和客户端建立新连接或者通信了。

初始化 `fd_set `类型的参数还需要使用相关的一些列操作函数，具体如下：

```c++
// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0  
void FD_CLR(int fd, fd_set *set);

// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1
int  FD_ISSET(int fd, fd_set *set);

// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1
void FD_SET(int fd, fd_set *set);

// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符
void FD_ZERO(fd_set *set);
```

>`fd_set`内存在用户区，通过`select()`会把这部分内容传递到内核里面（做一次数据拷贝），内核会基于拷贝后的集合进行线性检测，检测完之后，对满足条件的文件描述符写回到原先用户区的`fd_set`，对其进行更新。拿到结果后，可以遍历该集合进行`FD_ISSET`判断，得到满足条件的文件描述符，然后再对其是监听还是通信文件描述符进行判断，如果是监听，就与新客户建立新连接，如果是通信，就进行读写数据



### 基于select进行并发

如果在服务器基于 select 实现并发，其处理流程如下：

1. 创建监听的套接字 lfd = socket ();

2. 将监听的套接字和本地的 IP 和端口绑定 bind ()

3. 给监听的套接字设置监听 listen ()

4. 创建一个文件描述符集合 fd_set，用于存储需要检测读事件的所有的文件描述符（监听的文件描述符也要放入读事件的集合中，因为监听就是监听其读缓冲区是否有数据，是否有新链接）

   * 通过 FD_ZERO () 初始化

   * 通过 FD_SET () 将监听的文件描述符放入检测的读集合中

5. 循环调用 select ()，周期性的对所有的文件描述符进行检测

6. select () 解除阻塞返回，得到内核传出的满足条件的就绪的文件描述符集合

   * 通过 FD_ISSET () 判断集合中的标志位是否为 1
     * 如果这个文件描述符是监听的文件描述符，调用 accept () 和客户端建立连接
       * 将得到的新的通信的文件描述符，通过 FD_SET () 放入到检测集合中
   * 如果这个文件描述符是通信的文件描述符，调用通信函数和客户端通信
     * 如果客户端和服务器断开了连接，使用 FD_CLR () 将这个文件描述符从检测集合中删除
     * 如果没有断开连接，正常通信即可

7. 重复第 6 步

<img src="https://i.loli.net/2021/06/12/BzerAKwc2QW7gtZ.png" style="zoom: 25%;" />

>timeout时也可以根据需求，和图中不一样，继续进行检测。

客户端不需要使用 IO 多路转接进行处理，因为客户端和服务器的对应关系是 1：N，也就是说客户端是比较专一的，只能和一个连接成功的服务器通信。

虽然使用 select 这种 IO 多路转接技术可以降低系统开销，提高程序效率，但是它也有局限性：

* 待检测集合（第 2、3、4 个参数）需要频繁的在用户区和内核区之间进行数据的拷贝，效率低

* 内核对于 select 传递进来的待检测集合的检测方式是线性的
  * 如果集合内待检测的文件描述符很多，检测效率会比较低
  * 如果集合内待检测的文件描述符相对较少，检测效率会比较高
* 使用select能够检测的最大文件描述符个数有上限，默认是1024，这是在内核中被写死了的。

为了提高效率，可以采用多线程的方法，主线程进行`select()`操作，检测满足条件的文件描述符，通过不同的线程去处理监听或者通信数据的接收。



## poll

### `poll()`函数

poll 的机制与 select 类似，与 select 在本质上没有多大差别，使用方法也类似，下面的是对于二者的对比：

* 内核对应文件描述符的检测也是以线性的方式进行轮询，根据描述符的状态进行处理
* poll 和 select 检测的文件描述符集合会在检测过程中频繁的进行用户区和内核区的拷贝，它的开销随着文件描述符数量的增加而线性增大，从而效率也会越来越低。
* select检测的文件描述符个数上限是1024，poll没有最大文件描述符数量的限制
* select可以跨平台使用，poll只能在Linux平台使用

>一般不会使用poll，跨平台考虑select，linux用epoll

poll 函数的函数原型如下：

```c++
#include <poll.h>
// 每个委托poll检测的fd都对应这样一个结构体
struct pollfd {
    int   fd;         /* 委托内核检测的文件描述符 */
    short events;     /* 委托内核检测文件描述符的什么事件 */
    short revents;    /* 文件描述符实际发生的事件 -> 传出 */
};

struct pollfd myfd[n];
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

函数参数：

* fds: 这是一个 struct pollfd 类型的数组，里边存储了待检测的文件描述符的信息，这个数组中有三个成员：

  * fd：委托内核检测的文件描述符
  * events：委托内核检测的 fd 事件（输入、输出、错误），每一个事件有多个取值
  * revents：这是一个传出参数，数据由内核写入，存储内核检测之后的结果，不用初始化

  ![](https://i.loli.net/2021/06/12/RVIS6kbFaEZ4yNt.png)

  > 同时读写可以用`POLLIN | POLLOUT`

* nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1（也可以指定参数 1 数组的元素总个数）

* timeout: 指定 poll 函数的阻塞时长
  * -1：一直阻塞，直到检测的集合中有就绪的文件描述符（有事件产生）解除阻塞
  * 0：不阻塞，不管检测集合中有没有已就绪的文件描述符，函数马上返回
  * 大于 0：阻塞指定的毫秒（ms）数之后，解除阻塞

函数返回值：

* 失败： 返回 - 1
* 成功：返回一个大于 0 的整数，表示检测的集合中已就绪的文件描述符的总个数

使用 poll 和 select 进行 IO 多路转接的处理思路是完全相同的，但是使用 poll 编写的代码看起来会更直观一些，select 使用的位图的方式来标记要委托内核检测的文件描述符（每个比特位对应一个唯一的文件描述符），并且对这个 fd_set 类型的位图变量进行读写还需要借助一系列的宏函数，操作比较麻烦。而 poll 直接将要检测的文件描述符的相关信息封装到了一个结构体 struct pollfd 中，我们可以直接读写这个结构体变量。

另外 poll 的第二个参数有两种赋值方式，但是都和第一个参数的数组有关系：

* 使用参数 1 数组的元素个数
* 使用参数 1 数组中存储的最后一个有效元素对应的下标值 + 1

内核会根据第二个参数传递的值对参数 1 数组中的文件描述符进行线性遍历，这一点和 select 也是类似的。



## epoll

epoll全称evenpoll，是linux内核实现I/O多路复用的一个实现，epoll 是 select 和 poll 的升级版，相较于这两个前辈，epoll 改进了工作方式，因此它更加高效。

* 对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。
* select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是==回调机制==，效率高，处理效率也不会随着检测集合的变大而下降
* select和poll工作过程中存在内核/用户空间数据的频繁拷贝问题，==在epoll中内核和用户区使用的是**共享内存**（基于mmap内存映射区实现）==，省去了不必要的内存拷贝。
* 使用者需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测
* 使用 epoll 没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制

当多路复用的文件数量庞大、IO 流量频繁的时候，一般不太适合使用` select () `和 `poll ()`，这种情况下` select () `和` poll () `表现较差，推荐使用 `epoll ()`。

### epoll接口函数

```c++
#include <sys/epoll.h>

// 创建epoll实例，通过一棵红黑树管理待检测集合
int epoll_create(int size);

// 管理红黑树上的文件描述符(添加、修改、删除)
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

// 检测epoll树中是否有就绪的文件描述符
int epoll_wait(int epfd, struct epoll_event *event, int maxevents, int timeout);
```



#### 1. `int epoll_create(int size)`

创建一个红黑树模型的实例，用于管理待检测的文件描述符的集合。

* 函数参数`size`： Linux 内核 2.6.8 版本以后，这个参数是被忽略的，只需要指定一个大于 0 的数值就可以了。
* 函数返回值：
  * 失败时返回-1，并设置errno
  * 成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的 epoll 实例了



#### 2. `epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)` 

函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。

```C++
// 联合体, 多个变量共用同一块内存        
typedef union epoll_data {
 	void        *ptr;
	int          fd;	// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可
	uint32_t     u32;
	uint64_t     u64;
} epoll_data_t;

struct epoll_event {
	uint32_t     events;      /* Epoll events */
	epoll_data_t data;        /* User data variable */
};
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

函数参数：

* epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例
* op：这是一个枚举值，控制通过该函数执行什么操作
  * EPOLL_CTL_ADD：往 epoll 模型中添加新的节点
  * EPOLL_CTL_MOD：修改 epoll 模型中已经存在的节点
  * EPOLL_CTL_DEL：删除 epoll 模型中的指定的节点
  * .......
* fd：文件描述符，即要添加 / 修改 / 删除的文件描述符
* event：epoll 事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件
  * events：委托 epoll 检测的事件
    * EPOLLIN：读事件，接收数据，检测读缓冲区，如果有数据该文件描述符就绪
    * EPOLLOUT：写事件，发送数据，检测写缓冲区，如果可写该文件描述符就绪
    * EPOLLERR：异常事件
  * data：用户数据变量，这是一个联合体类型，通常情况下使用里边的 fd 成员，用于存储待检测的文件描述符的值，在调用 epoll_wait() 函数的时候这个值会被传出。

函数返回值：

* 失败：返回-1；
* 成功：返回0



#### 3. `epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)`

函数参数：

* epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例
* events：传出参数，这是一个结构体数组的地址，里边存储了已就绪的文件描述符的信息
* maxevents：修饰第二个参数，结构体数组的容量（元素个数）
* timeout：如果检测的 epoll 实例中没有已就绪的文件描述符，该函数阻塞的时长，单位 ms 毫秒
  * 0：函数不阻塞，不管 epoll 实例中有没有就绪的文件描述符，函数被调用后都直接返回
  * 大于 0：如果 epoll 实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回
  * -1：函数一直阻塞，直到 epoll 实例中有已就绪的文件描述符之后才解除阻塞


函数返回值：

* 成功：
  * 等于 0：函数是阻塞被强制解除了，没有检测到满足条件的文件描述符
  * 大于 0：检测到的已就绪的文件描述符的总个数
* 失败：返回 - 1

当在服务器端循环调用 epoll_wait() 的时候，就会得到一个就绪列表，并通过该函数的第二个参数传出：

```c++
struct epoll_event evs[1024];
int num = epoll_wait(epfd, evs, size, -1);
```

每当 epoll_wait() 函数返回一次，在 evs 中最多可以存储 size 个已就绪的文件描述符信息，但是在这个数组中实际存储的有效元素个数为 num 个，如果在这个 epoll 实例的红黑树中已就绪的文件描述符很多，并且 evs 数组无法将这些信息全部传出，那么这些信息会在下一次 epoll_wait() 函数返回的时候被传出。

通过 evs 数组被传递出的每一个有效元素里边都包含了已就绪的文件描述符的相关信息，这些信息并不是凭空得来的，这取决于我们在往 epoll 实例中添加节点的时候，往节点中初始化了哪些数据：

```C++
struct epoll_event ev;
// 节点初始化
ev.events = EPOLLIN;    
ev.data.fd = lfd;	// 使用了联合体中 fd 成员
// 添加待检测节点到epoll实例中
int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
```

在添加节点的时候，需要对这个 struct epoll_event 类型的节点进行初始化，当这个节点对应的文件描述符变为已就绪状态，这些被传入的初始化信息就会被原样传出。



### epoll的工作模式

#### 1. 水平模式（level triggered， LT）

LT是默认的工作方式，并且同时支持block和non-block socket。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行 IO 操作了。如果我们不作任何操作，内核还是会继续通知使用者。

水平模式的特点：

* 读事件：如果文件描述符对应的读缓冲区还有数据，读事件就会被触发，epoll_wait () 解除阻塞
  * 当读事件被触发，epoll_wait () 解除阻塞，之后就可以接收数据了
  * 如果接收数据的 buf 很小，不能全部将缓冲区数据读出，那么读事件会继续被触发，直到数据被全部读出，如果接收数据的内存相对较大，读数据的效率也会相对较高（减少了读数据的次数）
  * 因为读数据是被动的，必须要通过读事件才能知道有数据到达了，因此对于读事件的检测是必须的
* 写事件：如果文件描述符对应的写缓冲区可写，写事件就会被触发，epoll_wait () 解除阻塞
  * 当写事件被触发，epoll_wait () 解除阻塞，之后就可以将数据写入到写缓冲区了
  * 写事件的触发发生在写数据之前而不是之后，被写入到写缓冲区中的数据是由内核自动发送出去的
  * 如果写缓冲区没有被写满，写事件会一直被触发
  * 因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的

#### 2. 边沿模式（edge triggered，ET）

ET（edge-triggered）是高速工作方式，只支持no-block socket。在这种模式下，当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）。如果我们对这个文件描述符做 IO 操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。

边沿模式的特点:

* 读事件：当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件
  * 如果有新数据进入到读缓冲区，读事件被触发，epoll_wait () 解除阻塞
  * 读事件被触发，可以通过调用 read ()/recv () 函数将缓冲区数据读出
    * 如果数据没有被全部读走，并且没有新数据进入，读事件不会再次触发，只通知一次
    * 如果数据被全部读走或者只读走一部分，此时有新数据进入，读事件被触发，并且只通知一次
* 写事件：当写缓冲区状态可写，写事件只会触发一次
  * 如果写缓冲区被检测到可写，写事件被触发，epoll_wait () 解除阻塞
  * 写事件被触发，就可以通过调用 write ()/send () 函数，将数据写入到写缓冲区中
    * 写缓冲区从不满到被写满，期间写事件只会被触发一次
    * 写缓冲区从满到不满，状态变为可写，写事件只会被触发一次

epoll 的边沿模式下 epoll_wait () 检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高。



# 面试

准备面试，看面经的时候遇到的多的问题

## C++ 相关

### 变量的声明和定义有什么区别？

- 声明仅仅是把变量类型等信息提供给编译器，并不为其分配内存空间，而定义需要为变量分配内存空间；
- 变量可以在多处声明，如外部变量`extern`，但只能在一处定义。

### 指针和引用有什么区别？

- 指针是一种对象，用来存放某个对象的地址，占用内存空间，而引用是一种别名，不占用内存空间；
- 指针可以声明为空，之后进行初始化，普通指针可以随时更换所指对象，而引用必须在声明的时候初始化；
- 指针包含指向常量的指针和常量指针，而引用不包含常量引用，但包含对常量的引用。

### 什么是常引用？

- 常引用可以理解为常量指针，形式为`const typename & refname = varname`。
- 常引用下，原变量值不会被别名所修改。
- 原变量的值可以通过原名修改。
- 常引用通常用作只读变量别名或是形参传递。

### 野指针

- 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。
- 产生原因及解决办法：
  - 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
  - 指针free或delete之后没有及时置空 => 释放操作后立即置空。

### 数组名和指针（这里为指向数组首元素的指针）区别？

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

```C++
#include <iostream>

using namespace std;

int main() {
    int a[5] = {0,1,2,3,4};
    char str[] = "hello world";
    cout << "cout a " << a << endl;
    cout << "cout &a " << &a << endl;
    cout << "cout &a[0] " << &a[0] << endl; 
    // cout << "cout a++ " << a++ << endl; // error: lvalue required as increment operand
    cout << "cout a + 1 "  << a + 1 << endl;
    cout << "cout *(a + 1) " << *(a + 1) << endl;

    cout << "sizeof(a): " << sizeof(a) << endl;
    cout << "\n";
    cout << "str " << str << endl;
    cout << "&str " << &str << endl;
    cout << "sizeof(str): " << sizeof(str) << endl;
    cout << "str[1] " << str[1] << endl;
    cout << "&str[1] " << &str[1] << endl;
    
    const char *str1 = "hello world";
    cout << "str1 " << str1 << endl;
    cout << "sizeof(str1): " << sizeof(str1) << endl;
    cout << "str1[1] " << str1[1] << endl;
    cout << "&str1[1] " << &str1[1] << endl;
    return 0;
}
/*
输出：
cout a 0x61fe00
cout &a 0x61fe00
cout &a[0] 0x61fe00
cout a + 1 0x61fe04
cout *(a + 1) 1
sizeof(a): 20

str hello world
&str 0x61fdf4
sizeof(str): 12
str[1] e
&str[1] ello world
str1 hello world
sizeof(str1): 8
str1[1] e
&str1[1] ello world
*/
```



## 计算机通信网

### TCP三次握手四次挥手

#### 三次握手

所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的顺序号和确认号并交换 TCP信息

![](https://raw.githubusercontent.com/chenwk96/picgoImage/main/20210702220306.png)

* 第一次握手：客户端请求建立连接，向服务端发送一个**同步报文**（SYN=1），同时选择一个随机数 seq = x 作为**初始序列号**
* 服务端收到连接请求报文后，如果同意建立连接，则向客户端发送**同步确认报文**（SYN=1，ACK=1），确认号为 ack = x + 1，同时选择一个随机数 seq = y 作为**初始序列号**
* 第三次握手：客户端收到服务端的确认后，向服务端发送一个**确认报文**（ACK=1），确认号为 ack = y + 1，序列号为 seq = x + 1

**为什么是三次，而不是两次、四次？**

为什么不是两次？因为只有两次的话，服务端向客户发送同步确认SYN/ACK报文后，就会认为连接建立。但是如果客户端没有收到这个报文，就会任务连接没有建立。服务端的资源就会浪费掉。

为什么不是四次？三次就够了吧，当然可以使用更多的通信次数交换相同的信息，使用两次无法保证建立TCP连接，使用三次握手是建立连接所需要的最下次数。

- 第一次握手：服务端确认“自己收、客户端发”报文功能正常
- 第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立
- 第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信

**四次挥手**

![](https://raw.githubusercontent.com/chenwk96/picgoImage/main/20210702221342.png)

- 客户端Client进程发出连接释放报文，并且停止发送数据。其中FIN=1，顺序号为seq=m（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端Client进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- 服务器Server收到连接释放报文，发出确认报文，ACK=1，ack=m+1，并且带上自己的顺序号seq=n，此时，服务器Server就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端Client向服务器的方向就释放了，这时候处于半关闭状态，即客户端Client已经没有数据要发送了，但是服务器Server若发送数据，客户端Client依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
- 客户端Client收到服务器Server的确认信息后，此时，客户端Client就进入FIN-WAIT-2（终止等待2）状态，等待服务器Server发送连接释放报文（在这之前还需要接受服务器Server发送的最后的数据）。
- 服务器Server将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=m+1，由于在半关闭状态，服务器Server很可能又发送了一些数据，假定此时的顺序号为seq=p，此时，服务器Server就进入了LAST-ACK（最后确认）状态，等待客户端Client的确认。
- 客户端Client收到服务器Server的连接释放报文后，必须发出确认，ACK=1，ack=p+1，而自己的顺序号是seq=m+1，此时，客户端Client就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端Client撤销相应的TCB（保护程序）后，才进入CLOSED状态。
- 服务器Server只要收到了客户端Client发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器Server结束TCP连接的时间要比客户端Client早一些。

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

因为当客户端发起关闭连接的请求时，发出的FIN，仅代表客户端没有需要发送给服务器端的数据了。而如果服务器端如果仍有数据需要发送给客户端的话，响应报文ACK和结束报文FIN则就不能同时发送给客户端了。此时，服务器端会先返回一个响应报文，代表接收到了客户端发出的FIN请求，而后在数据传输完了之后，再发出FIN请求，表示服务器端已经准备好断开连接了。所以关闭连接的时候是四次握手。

### Time_wait 作用

**只有发起连接终止的一方会进入 TIME_WAIT 状态**

1. **为了确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭**。

   TCP 在设计的时候，做了充分的容错性设计，比如，TCP 假设报文会出错，需要重传。在这里，如果图中客户端 的 ACK 报文没有传输成功，那么服务器 就会重新发送 FIN 报文。如果客户端没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误。现在客户端 知道自己处于 TIME_WAIT 的状态，就可以在接收到 FIN 报文之后，重新发出一个 ACK 报文，使得主机 2 可以进入正常的 CLOSED 状态。

2. 和连接“化身”和报文迷走有关系，为了让旧连接的重复分节在网络中自然消失。

   在网络中，经常会发生报文经过一段时间才能到达目的地的情况，产生的原因是多种多样的，如路由器重启，链路突然出现故障等。如果迷走报文到达时，发现 TCP 连接四元组（源 IP，源端口，目的 IP，目的端口）所代表的连接不复存在，那么很简单，这个报文自然丢弃。但在原连接中断后，又重新创建了一个原连接的“化身”，说是化身其实是因为这个连接和原先的连接四元组完全相同，如果迷失报文经过一段时间也到达，那么这个报文会被误认为是连接“化身”的一个 TCP 分节，这样就会对 TCP 通信产生影响，所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组一定都是新化身所产生的。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



## 操作系统



